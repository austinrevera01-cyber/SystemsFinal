%PART_A_YAW_MODEL  Linear yaw-rate model of the IAC vehicle driven by steering voltage.
%
% This script constructs a state-space model from steering motor input voltage (V)
% to vehicle yaw rate (rad/s). It prints the solved variables, the voltage-to-yaw
% transfer function (numeric and symbolic), and plots eigenvalues, step response,
% Bode magnitude/phase, and sinusoidal responses on separate figures.
%
% To override defaults, edit the "User options" block below or set a workspace
% struct named `user_options` with matching fields before running the script.
%
% Author: Generated by ChatGPT (GPT-5.1-Codex-Max)
% Date: 2025-XX-XX

%% Housekeeping
clc; % clear command window and previous prompts for clean reporting

%% User options (edit as needed)
if exist('user_options', 'var')
    options = user_options;
else
    options = struct();
end

%% Parameter and simulation setup
params = default_parameters();
if isfield(options, 'params')
    params = merge_structs(params, options.params);
end

Vel = get_option(options, 'Vel', 15);         % m/s constant vehicle speed
Vstep = get_option(options, 'Vstep', 4);       % step voltage magnitude [V]
sim_time = get_option(options, 'sim_time', 2); % step simulation time [s]

%% Build linear model
[sys_lat, derived, tf_sys] = build_voltage_to_yaw_model(params, Vel);
results = struct();
results.model = sys_lat;
results.parameters = params;
results.derived = derived;
results.eigs = eig(sys_lat.A);
results.transfer_function = tf_sys;

%% Display all computed values
print_parameters(params, Vel, Vstep, sim_time);
print_transfer_function(tf_sys);
print_symbolic_transfer_function(params, Vel);
print_derived_variables(derived, results.eigs);

[t_step, y_step] = step(sys_lat * Vstep, sim_time);
results.step.time = t_step;
results.step.yaw_rate = y_step;
results.step.input_voltage = Vstep;
print_step_results(results.step, sys_lat);

sweep_freq_hz = get_option(options, 'sinusoid_freq_hz', logspace(-1, 1.3, 8));
sweep_amp = get_option(options, 'sinusoid_amplitude', 1.5);
results.sweep = run_sinusoidal_sweep(sys_lat, sweep_amp, sweep_freq_hz, sim_time);
print_sweep_results(results.sweep);

[mag, phase, wout] = bode(sys_lat, {2*pi*min(sweep_freq_hz), 2*pi*max(sweep_freq_hz)});
results.bode.w = wout;
results.bode.mag = squeeze(mag);
results.bode.phase = squeeze(phase);
print_bode_results(results.bode);

if exist('run_Indy_car', 'file') == 2
    results.reference = simulate_run_Indy_car(Vstep, Vel, sim_time);
else
    results.reference = [];
end

%% Plot results
plot_results(results);

%% Local functions
function params = default_parameters()
%DEFAULT_PARAMETERS Default physical parameters for the IAC yaw model.
% These values are approximate and intended as a starting point for tuning.
    params = struct();

    % Motor (Maxon RE-30 60 W) approximated data
    params.motor.R = 0.9;          % Armature resistance [Ohm]
    params.motor.L = 0.45e-3;      % Armature inductance [H]
    params.motor.Kt = 0.0335;      % Torque constant [N*m/A]
    params.motor.Ke = 0.0335;      % Back-EMF constant [V/(rad/s)]
    params.motor.J = 3.5e-6;       % Rotor inertia [kg*m^2]
    params.motor.B = 2e-5;         % Viscous friction [N*m*s/rad]

    % Gearhead (GP32 21:1)
    params.gear.N = 21;            % Gear ratio (motor : rack)
    params.gear.eff = 0.75;        % Efficiency

    % Steering mechanism mapping
    params.steering.rack_per_rad = 0.003; % Rack travel per motor rad [m/rad]
    params.steering.rack_to_wheel = 70;   % Steer angle per meter rack [rad/m]
    params.steering.max_wheel_angle = deg2rad(20); % Saturation for reference plots

    % Vehicle (Dallara IL-15 approximations)
    params.vehicle.mass = 710;         % kg
    params.vehicle.Iz = 910;           % kg*m^2
    params.vehicle.a = 1.5;            % m (CG to front axle)
    params.vehicle.b = 1.5;            % m (CG to rear axle)
    params.vehicle.Cf = 8.0e4;         % N/rad front cornering stiffness
    params.vehicle.Cr = 8.5e4;         % N/rad rear cornering stiffness
end

function value = get_option(opts, name, default)
%GET_OPTION Helper to read options with defaults.
    if isfield(opts, name)
        value = opts.(name);
    else
        value = default;
    end
end

function merged = merge_structs(base, override)
%MERGE_STRUCTS Recursively merge two structs (override into base).
    merged = base;
    fields_override = fieldnames(override);
    for k = 1:numel(fields_override)
        fname = fields_override{k};
        if isstruct(override.(fname))
            merged.(fname) = merge_structs(base.(fname), override.(fname));
        else
            merged.(fname) = override.(fname);
        end
    end
end

function print_parameters(params, Vel, Vstep, sim_time)
%PRINT_PARAMETERS Echo numeric parameters and simulation settings.
    fprintf('Simulation settings:\n');
    fprintf('    Vehicle speed (Vel)      = %.3f m/s\n', Vel);
    fprintf('    Step input (Vstep)       = %.3f V\n', Vstep);
    fprintf('    Simulation time          = %.3f s\n', sim_time);
    fprintf('\nMotor parameters:\n');
    fprintf('    R  = %.6f Ohm\n', params.motor.R);
    fprintf('    L  = %.6e H\n', params.motor.L);
    fprintf('    Kt = %.6f N*m/A\n', params.motor.Kt);
    fprintf('    Ke = %.6f V/(rad/s)\n', params.motor.Ke);
    fprintf('    J  = %.6e kg*m^2\n', params.motor.J);
    fprintf('    B  = %.6e N*m*s/rad\n', params.motor.B);
    fprintf('\nGear parameters:\n');
    fprintf('    N   = %.6f (motor:rack)\n', params.gear.N);
    fprintf('    eff = %.6f\n', params.gear.eff);
    fprintf('\nSteering mapping:\n');
    fprintf('    rack_per_rad   = %.6f m/rad\n', params.steering.rack_per_rad);
    fprintf('    rack_to_wheel  = %.6f rad/m\n', params.steering.rack_to_wheel);
    fprintf('    max_wheel_angle= %.6f rad\n', params.steering.max_wheel_angle);
    fprintf('\nVehicle parameters:\n');
    fprintf('    mass m = %.6f kg\n', params.vehicle.mass);
    fprintf('    Iz     = %.6f kg*m^2\n', params.vehicle.Iz);
    fprintf('    a      = %.6f m\n', params.vehicle.a);
    fprintf('    b      = %.6f m\n', params.vehicle.b);
    fprintf('    Cf     = %.6f N/rad\n', params.vehicle.Cf);
    fprintf('    Cr     = %.6f N/rad\n', params.vehicle.Cr);
    fprintf('\n');
end

function print_transfer_function(tf_sys)
%PRINT_TRANSFER_FUNCTION Pretty-print the yaw-rate transfer function.
    [num, den] = tfdata(tf_sys, 'v');
    fprintf('Yaw-rate transfer function (voltage to yaw rate):\n');
    tf_str = poly2str(num, 's');
    den_str = poly2str(den, 's');
    fprintf('    G(s) = (%s) / (%s)\n', tf_str, den_str);
    fprintf('    Numerator coefficients: %s\n', mat2str(num));
    fprintf('    Denominator coefficients: %s\n\n', mat2str(den));
end

function print_symbolic_transfer_function(params, Vel)
%PRINT_SYMBOLIC_TRANSFER_FUNCTION Display G(s) in terms of physical variables.
    fprintf('Symbolic voltage-to-yaw-rate transfer function (variable form):\n');

    s = sym('s', 'real');
    R = sym('R', 'real');
    Kt = sym('Kt', 'real');
    Ke = sym('Ke', 'real');
    J = sym('J', 'real');
    Bm = sym('Bm', 'real');
    N = sym('N', 'real');
    eff = sym('eff', 'real');
    rack_per_rad = sym('rack_per_rad', 'real');
    rack_to_wheel = sym('rack_to_wheel', 'real');
    m = sym('m', 'real');
    Iz = sym('Iz', 'real');
    a = sym('a', 'real');
    b = sym('b', 'real');
    Cf = sym('Cf', 'real');
    Cr = sym('Cr', 'real');
    Vel_sym = sym('Vel', 'real');

    rack_gain = rack_per_rad * eff * N; % use N in numerator to match Part A convention
    steer_gain = rack_gain * rack_to_wheel;

    A_act = [0 1; 0 -(Ke * Kt / (R * J)) - Bm / J];
    B_act = [0; Kt / (R * J)];

    A_lat = [-(Cf + Cr) / (m * Vel_sym), (-a * Cf + b * Cr) / (m * Vel_sym) - Vel_sym; ...
             (-a * Cf + b * Cr) / (Iz * Vel_sym), -(a^2 * Cf + b^2 * Cr) / (Iz * Vel_sym)];
    B_lat = [Cf / m; a * Cf / Iz];

    A = blkdiag(A_act, A_lat);
    Bv = [B_act; B_lat * steer_gain];
    C = [0 0 0 1];
    D = 0;

    % 4th-order form coefficients (latency block + actuator block)
    A_coef = -(A_lat(1,1) + A_lat(2,2));
    B_coef = A_lat(1,1) * A_lat(2,2) - A_lat(1,2) * A_lat(2,1);
    C_coef = B_lat(2);
    D_coef = A_lat(2,1) * B_lat(1) - A_lat(1,1) * B_lat(2);
    Je = J;
    be = Ke * Kt / R + Bm;
    overall_gain = (N * eff * rack_per_rad * rack_to_wheel) * (Kt / R);

    G_form = simplify(overall_gain * (C_coef * s + D_coef) / ((Je * s^2 + be * s) * (s^2 + A_coef * s + B_coef)));
    G_sym = simplify(C * ((s * eye(4) - A) \ Bv) + D);

    fprintf('    Target 4th-order form: G(s) = (N*Kt*(C*s + D)*eff*rack_per_rad*rack_to_wheel/R) / ((Je*s^2 + be*s)*(s^2 + A*s + B))\n');
    fprintf('        Je = J,   be = Ke*Kt/R + Bm\n');
    fprintf('        C  = %s, D = %s (from bicycle model)\n', char(C_coef), char(D_coef));
    fprintf('        A  = %s, B = %s (from bicycle model)\n', char(A_coef), char(B_coef));
    fprintf('    Derived symbolic G(s) = %s\n', char(G_form));
    fprintf('    State-space G(s)      = %s\n', char(G_sym));
    fprintf(['    Parameters: R, Kt, Ke, J, Bm, N, eff, rack_per_rad, rack_to_wheel, ', ...
             'm, Iz, a, b, Cf, Cr, Vel\n\n']);
end

function print_derived_variables(derived, eigs_vals)
%PRINT_DERIVED_VARIABLES Echo derived numeric values and eigenvalues for traceability.
    fprintf('Derived parameter values (numeric):\n');
    fprintf('    rack_gain    = %.6f m/rad (motor to rack)\n', derived.rack_gain);
    fprintf('    steer_gain   = %.6f rad/rad (wheel steer per motor rad)\n', derived.steer_gain);
    fprintf('    transfer num = %s\n', mat2str(derived.transfer_num));
    fprintf('    transfer den = %s\n', mat2str(derived.transfer_den));
    fprintf('    4th-order form params: Je=%.6e, be=%.6e, A=%.6e, B=%.6e, C=%.6e, D=%.6e\n', ...
            derived.Je, derived.be, derived.A_coef, derived.B_coef, derived.C_coef, derived.D_coef);
    fprintf('    Motor A matrix  = [%s; %s]\n', num2str(derived.A_act(1,:)), num2str(derived.A_act(2,:)));
    fprintf('    Lateral A row1  = %s\n', num2str(derived.A_lat(1,:)));
    fprintf('    Lateral A row2  = %s\n', num2str(derived.A_lat(2,:)));
    fprintf('Eigenvalues of combined system:\n');
    for k = 1:numel(eigs_vals)
        fprintf('    lambda_%d = %.6f %+.6fi\n', k, real(eigs_vals(k)), imag(eigs_vals(k)));
    end
    fprintf('\n');
end

function [sys, derived, tf_sys] = build_voltage_to_yaw_model(params, Vel)
%BUILD_VOLTAGE_TO_YAW_MODEL Construct combined actuator + bicycle model.
    rack_gain = params.steering.rack_per_rad * params.gear.eff * params.gear.N;
    steer_gain = rack_gain * params.steering.rack_to_wheel;

    J_act = params.motor.J;
    B_act = params.motor.B;

    A_act = [0 1; 0 -(params.motor.Ke * params.motor.Kt / (params.motor.R * J_act)) - B_act / J_act];
    B_act = [0; params.motor.Kt / (params.motor.R * J_act)];
    C_lat = [0 1];

    m = params.vehicle.mass;
    Iz = params.vehicle.Iz;
    a = params.vehicle.a;
    b = params.vehicle.b;
    Cf = params.vehicle.Cf;
    Cr = params.vehicle.Cr;

    A_lat = [-(Cf + Cr) / (m * Vel), (-a * Cf + b * Cr) / (m * Vel) - Vel; ...
             (-a * Cf + b * Cr) / (Iz * Vel), -(a^2 * Cf + b^2 * Cr) / (Iz * Vel)];
    B_lat = [Cf / m; a * Cf / Iz];

    A = blkdiag(A_act, A_lat);
    B = [B_act; B_lat * steer_gain;];
    C = [zeros(1,2), C_lat];
    D = 0;

    sys = ss(A, B, C, D);
    tf_sys = tf(sys);
    [num, den] = tfdata(tf_sys, 'v');
    Je = params.motor.J;
    be = params.motor.Ke * params.motor.Kt / params.motor.R + params.motor.B;
    A_coef = -(A_lat(1,1) + A_lat(2,2));
    B_coef = A_lat(1,1) * A_lat(2,2) - A_lat(1,2) * A_lat(2,1);
    C_coef = B_lat(2);
    D_coef = A_lat(2,1) * B_lat(1) - A_lat(1,1) * B_lat(2);
    derived.transfer_num = num;
    derived.transfer_den = den;
    derived.rack_gain = rack_gain;
    derived.steer_gain = steer_gain;
    derived.A_act = A_act;
    derived.A_lat = A_lat;
    derived.A_coef = A_coef;
    derived.B_coef = B_coef;
    derived.C_coef = C_coef;
    derived.D_coef = D_coef;
    derived.Je = Je;
    derived.be = be;
end

function print_step_results(step_struct, sys_lat)
%PRINT_STEP_RESULTS Summarize the step response metrics and eigenvalues.
    info = stepinfo(sys_lat * step_struct.input_voltage);
    fprintf('Step response summary (yaw rate):\n');
    fprintf('    RiseTime     = %.6f s\n', info.RiseTime);
    fprintf('    SettlingTime = %.6f s\n', info.SettlingTime);
    fprintf('    Overshoot    = %.6f %%\n', info.Overshoot);
    fprintf('    Peak         = %.6f rad/s at %.6f s\n', info.Peak, info.PeakTime);
    final_value = step_struct.yaw_rate(end);
    fprintf('    FinalValue   = %.6f rad/s\n\n', final_value);
end

function sweep = run_sinusoidal_sweep(sys, amplitude, freq_hz, sim_time)
%RUN_SINUSOIDAL_SWEEP Generate sinusoidal responses at multiple frequencies.
    Ts = 0.001;
    sweep = struct('freq_hz', freq_hz(:), 'responses', []);

    for k = 1:numel(freq_hz)
        w = 2 * pi * freq_hz(k);
        t = 0:Ts:sim_time;
        u = amplitude * sin(w * t);
        y = lsim(sys, u, t);
        sweep.responses(k).time = t(:);
        sweep.responses(k).input = u(:);
        sweep.responses(k).yaw_rate = y;
    end
end

function print_sweep_results(sweep)
%PRINT_SWEEP_RESULTS Report sinusoidal sweep steady-state amplitudes.
    fprintf('Sinusoidal sweep results (input amplitude %.3f V):\n', ...
            max(abs(sweep.responses(1).input)));
    for k = 1:numel(sweep.freq_hz)
        yaw = sweep.responses(k).yaw_rate;
        ss_amp = (max(yaw) - min(yaw)) / 2;
        fprintf('    %.4f Hz -> steady yaw amplitude %.6f rad/s\n', sweep.freq_hz(k), ss_amp);
    end
    fprintf('\n');
end

function print_bode_results(bode_data)
%PRINT_BODE_RESULTS Echo Bode magnitude/phase at each computed frequency.
    fprintf('Bode sample points (voltage -> yaw rate):\n');
    for k = 1:numel(bode_data.w)
        freq_hz = bode_data.w(k) / (2*pi);
        mag_db = 20*log10(bode_data.mag(k));
        phase_deg = bode_data.phase(k);
        fprintf('    %.6f Hz : %.3f dB, %.3f deg\n', freq_hz, mag_db, phase_deg);
    end
    fprintf('\n');
end

function ref = simulate_run_Indy_car(Vin, Vel, sim_time)
%SIMULATE_RUN_INDY_CAR Call the provided p-code model for validation.
    Ts = 0.001;
    steps = floor(sim_time / Ts);
    ref.time = (0:steps-1)' * Ts;
    ref.yaw_rate = zeros(steps,1);
    ref.motor_angle = zeros(steps,1);

    clear run_Indy_car

    for k = 1:steps
        [~, gyro, motor_counts] = run_Indy_car(Vin, Vel);
        ref.yaw_rate(k) = gyro;
        ref.motor_angle(k) = motor_counts;
    end
end

function plot_results(results)
%PLOT_RESULTS Generate diagnostic plots for quick inspection.
    figure('Name','Eigenvalues');
    plot(real(results.eigs), imag(results.eigs), 'x');
    grid on; xlabel('Real'); ylabel('Imag');
    title('Eigenvalues of Linearized System');

    figure('Name','Step Response');
    plot(results.step.time, results.step.yaw_rate);
    grid on; xlabel('Time [s]'); ylabel('Yaw rate [rad/s]');
    title(sprintf('Yaw-rate Step Response (%.1f V input)', results.step.input_voltage));

    figure('Name','Bode Magnitude');
    semilogx(results.bode.w/(2*pi), 20*log10(results.bode.mag(:)));
    grid on; xlabel('Frequency [Hz]'); ylabel('Magnitude [dB]');
    title('Voltage-to-Yaw Bode Magnitude');

    figure('Name','Bode Phase');
    semilogx(results.bode.w/(2*pi), results.bode.phase(:));
    grid on; xlabel('Frequency [Hz]'); ylabel('Phase [deg]');
    title('Voltage-to-Yaw Bode Phase');

    figure('Name','Sinusoidal Responses');
    for k = 1:numel(results.sweep.freq_hz)
        plot(results.sweep.responses(k).time, results.sweep.responses(k).yaw_rate, 'DisplayName', ...
             sprintf('%.2f Hz', results.sweep.freq_hz(k)));
        hold on;
    end
    grid on; xlabel('Time [s]'); ylabel('Yaw rate [rad/s]');
    title('Sinusoidal Responses'); legend('show');

    if ~isempty(results.reference)
        figure('Name','Model vs. p-code Validation');
        plot(results.reference.time, results.reference.yaw_rate, 'k', 'DisplayName','run\_Indy\_car');
        hold on;
        plot(results.step.time, results.step.yaw_rate, 'r--', 'DisplayName','Linear model');
        grid on; xlabel('Time [s]'); ylabel('Yaw rate [rad/s]');
        title('Yaw-rate Validation'); legend('show');
    end
end
